[{"id":0,"href":"/posts/tools/hugo/","title":"Hugo+Github搭建个人博客","section":"tools","content":"Hugo是基于Go语言编写的静态博客框架，利用它结合Github Pages可以很容易的搭建出个人博客。\nHugo安装\r#\r\rWindows系统下安装步骤如下：\n1.打开网站 https://github.com/gohugoio/hugo/releases\r2.下载 hugo_x.xx.x_Windows-64bit.zip\r3.解压然后安装到某文件夹内\r4.将 hugo.exe 所在文件夹添加至Path环境变量\r5.hugo version 验证是否安装成功\r问题：因为众所周知的原因可能下载不成功。\n其它问题等请参考\rHugo官网\nhugo命令\r#\r\r使用方法:\rhugo\rhugo [flags]\rhugo [command]\rhugo [command] [flags]\r节选的 command:\rnew 为你的站点创建新的内容\rserver 一个高性能的web服务器\r节选的 flags:\r-D, --buildDrafts 包括被标记为draft的文章\r-E, --buildExpired 包括已过期的文章\r-F, --buildFuture 包括将在未来发布的文章\r举几个栗子:\rhugo -D 生成静态文件并包括draft为true文章\rhugo new post/new-content.md 新建一篇文章\rhugo new site mysite 新建一个称为mysite的站点\rhugo server -D 启动服务器并包括draft为true文章\r建立站点\r#\r\r将会在运行此命令的位置新建一个名为myblog的站点：\nhugo new site myblog\r生成的站点目录及作用是：\n.\r├── archetypes 储存.md的模板文件default.md\r├── content 存放所有的博客文章（.md文件）\r├── data 储存数据文件供模板调用\r├── layouts 存放的是站点的模板文件\r├── static 存放js/css/img等静态资源\r├── themes 存放站点的主题\r└── config.toml 配置文件\r注意： 此处archetypes、layouts和static文件夹的优先级高于主题下的同名文件夹。当需要稍稍修改主题时，复制到根目录下的对应文件夹再修改，则日后无git冲突问题。\n此外，执行hugo命令后，还会生成一个用于储存生成静态文件的public文件夹。\n添加主题\r#\r\rhugo主题非常多，如站点使用的是even主题，在博客根目录下执行：\n$ git clone https://github.com/olOwOlo/hugo-theme-even themes/even\r每个主题都会有不同的参数配置，将 themes/even/exampleSite/config.toml 复制到博客根目录下进行自定义配置。\n新建文章\r#\r\r新建文章的代码为：\nhugo new post/my-first-post.md\r可通过 front-matter 针对每一篇文章单独进行设置，themes/even/archetypes/default.md 文件陈列了所有可用的参数，通常将该文件复制到站点根目录archetypes文件夹下并根据需要配置。如本站点的 front-matter 为：\n---\rtitle: \u0026quot;{{ replace .TranslationBaseName \u0026quot;-\u0026quot; \u0026quot; \u0026quot; | title }}\u0026quot;\rdate: {{ .Date }}\rdraft: true\rdescription: \u0026quot;\u0026quot;\rtags: []\rcategories: []\r---\r摘要部分\r\u0026lt;!--more--\u0026gt;\rPS: Hugo的配置文件和文章中引用图片都是从static作为根目录的。\n运行站点\r#\r\rhugo server -t even --buildDrafts\ror\rhugo server --theme=even --buildDrafts\ror\rhugo server -D\rPS: 若config.toml指定了theme可省略参数，\u0026ndash;buildDrafts参数目的是指定编译draft为true的文章。\n在站点根目录下运行此命令后，即可通过http://localhost:1313/访问博客站点。\n发布到Github\r#\r\r首先要创建一个Github仓库且名字为IDName.github.io，然后执行以下命令生成静态网站（public文件夹下）：\nhugo --theme=even --baseUrl=\u0026quot;https://IDName.github.io\u0026quot; --buildDrafts\rPS: 若config.toml指定了theme或baseUrl参数则此处可省略。\n然后依次执行以下命令：\ncd public\rgit init\rgit add .\rgit commit -m \u0026quot;我的hugo博客第一次提交\u0026quot;\r#关联远端仓库\rgit remote add origin https://github.com/IDName/IDName.github.io.git\rgit push -u origin master\r注意这里有个问题是当每次本地写完博客后都需要提交至远程仓库，特别繁琐。故可以创建deploy.bat批处理文件自动执行：\n::表示进入E盘\re:\rcd E:\\GoLang\\myblog\rhugo --theme=even --baseUrl=\u0026quot;https://IDName.github.io\u0026quot; --buildDrafts\rcd public\r::git init 注释\rgit add .\rgit commit -m \u0026quot;updated\u0026quot;\rgit push\rcd ..\rpause\r针对自己博客源地址进行相应修改即可。\nPS: linux系统可编写makefile文件自动执行脚本。有条件的也可购买云服务器部署博客。\n绑定个人域名\r#\r\r  首先得有自己的域名，有了域名之后进行CNAME解析至https://IDName.github.io;\n  点击IDName.github.io仓库，在settings下的GitHub Pages中填写自己域名并保存，或直接在code页面中创建CNAME文件并填写自己域名。\n  PS：这里有个问题，当在本地public文件夹下git push出错时可能是由于修改了远程github仓，此时可以先git pull，然后在重新生成public并执行deploy.bat文件。\n 本文参考： olOwOlo的个人博客 HUGO主题book HUGO中文文档 "},{"id":1,"href":"/posts/golang/%E5%9F%BA%E7%A1%80/%E5%AF%BC%E5%85%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/","title":"导入及环境准备","section":"基础","content":"golang语言，快速写出高效率的代码。\n编程语言分类\r#\r\r按编译及运行方式分类\n 按编译类型划分，编程语言分为三种，编译型、解释型和混合型。编译型语言效率更高，性能更好。\n😊编译型语言将代码由编译器编为二进制运行，常见的如C/C++、Golang。\n😊解释型语言运行时通过解释器在线翻译代码为处理器认识的二进制运行，常见的解释型语言有Python、PHP、JS、SQL、R。\n😊混合型语言指的是运行时先编译为中间代码，再解释执行，常见的有Java、C#、Visual Basic、.Net。\n 按程序设计方法分类\n 按程序设计方法分为面向过程、面向对象和面向接口编程。\n😊面向过程：C 😊面向对象：Java、C#、Python等 😊面向接口：Golang\n go环境搭建\r#\r\r1、下载并安装需要版本的glang Go官方镜像站；\n2、设置GOROOT环境变量为上一步安装目录，并将$GOROOT/bin 加入系统环境变量；\n3、在适当位置建立workspace(里面包含bin、pkg、src目录)文件夹，设置GOPATH为workspace目录(新版本go可不设置)；\n4、命令行执行go version看到所安装版本的go版本即为安装成功。\n推荐使用免费的IDE VSCode，下载安装后需要再安装插件和所需扩展。\ngo命令\r#\r\r命令格式：go  [arguments]\n执行go help命令可查看go命令帮助。常用的go命令如下：\n   常用命令 解释     go version 查看go版本号   go build 编译go文件   go test 执行go测试用例   go clean -modcache 清理下载的mod缓存文件    包管理\r#\r\r基本设置\r#\r\r从go 1.14开始，默认使用go module 作为包管理工具。要启用go module，需设置GO111MODULE和GOPROXY，对其解释如下。\nGO111MODULE：\n 1、GO111MODULE=off禁用模块支持，编译时会从GOPATH和vendor文件夹中查找包。\n2、GO111MODULE=on启用模块支持，编译时忽略GOPATH和vendor文件夹，根据 go.mod下载依赖。\n3、GO111MODULE=auto，当项目在$GOPATH/src外且项目根目录有go.mod文件时，开启模块支持。\n GOPROXY：\nGo1.13之后GOPROXY默认值为https://proxy.golang.org，在国内是无法访问的，所以需设置GOPROXY\ngo env -w GOPROXY=https://goproxy.cn,direct \n终端执行go help mod 即可查看其用法。\n go mod download 下载依赖的module到本地cache（默认为$GOPATH/pkg/mod目录）\ngo mod edit 编辑go.mod文件\ngo mod graph 打印模块依赖图\ngo mod init 初始化当前文件夹, 创建go.mod文件\ngo mod tidy 增加缺少的module，删除无用的module\ngo mod vendor 将依赖复制到vendor下\ngo mod verify 校验依赖\ngo mod why 解释为什么需要依赖\n go.mod文件\r#\r\rgo mod文件记录了项目需要的依赖信息，其支持三种格式的引用，大致结构如下：\nmodule github.com/codemgo/test\rgo 1.16\rrequire (\r//三种引入方式：语义化版本号 + git的分支或tag + git提交hash值\rgopkg.in/vmihailenco/msgpack.v2 v2.9.1\rgopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7\rgithub.com/tatsushid/go-fastping v0.0.0-20160109021039-d7bb493dee3e\r//间接引用\rgoogle.golang.org/appengine v1.6.1 // indirect\r)\rreplace (\rgopkg.in/vmihailenco/msgpack.v2 v2.9.1 =\u0026gt; gopkg.in/vmihailenco/msgpack.v2 v2.9.3\rgolang.org/x/text =\u0026gt; github.com/golang/text v0.3.0\r)\r包加载\r#\r\r在main函数执行之前，Go引导程序会先对整个程序的包进行初始化。\n 从main函数引用的包进行开始，逐级查找包的引用，直到没有引用其它包的包，最终形成一个包引用的有向无序图； Go编译器会将有向无序图转换为一棵树，从叶子节点逐层向上进行初始化； 单个包的初始化顺序为 常量 —\u0026gt; 全局变量 —\u0026gt; init函数（main中也可以有init函数）。  跨平台编译\r#\r\rgo语言支持跨平台编译，如Linux编译Windows可执行文件： CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build\nGOOS：目标平台的操作系统（darwin、freebsd、linux、windows）\nGOARCH：目标平台的体系架构（386、amd64、arm等）\n交叉编译不支持 CGO 所以要禁用它。\n 本文参考：\n\r李文周的博客\n"},{"id":2,"href":"/posts/tools/markdown/","title":"Markdown的基本语法","section":"tools","content":"第一篇正式文章吧，记录Markdown的用法。\n标题\r#\r\r使用 # 号可表示 1-6 级标题：\n# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 段落格式\r#\r\r换行\r#\r\r行尾的两个以上空格加回车(换行) or 段落后使用一个空行(新段)。\n **空格：**在输入连续的空格后，Typora 会在编辑器视图里为你保留这些空格，但当你打印或导出时，这些空格会被省略成一个。你可以在源代码模式下，为每个空格前加一个 \\ 转义符，或者直接使用 HTML 风格的 \u0026amp;nbps; 来保持连续的空格。\n**软换行：**需要说明的是，在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。在 Typora 中，你可以通过 Shift + Enter 完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。\n**硬换行：**你可以通过 空格 + 空格 + Shift + Enter 完成一次硬换行，而这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。\n**换段：**你可以通过 Enter 完成一次换段。Typora 会自动帮你完成两次 Shift + Enter 的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。\n 字体\r#\r\r*斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ 斜体文本\n斜体文本\n粗体文本\n粗体文本\n粗斜体文本\n粗斜体文本\n分隔线\r#\r\r用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。\n*** * * * - - - --------    删除线\r#\r\rBAIDU.COM ~~BAIDU.COM~~ BAIDU.COM\nBAIDU.COM\n下划线\r#\r\r\u0026lt;u\u0026gt;带下划线文本\u0026lt;/u\u0026gt; 带下划线文本\n脚注\r#\r\r脚注是对文本的补充说明。\n创建脚注格式类似这样 [^RUNOOB]。 [^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！ 创建脚注格式类似这样 1。\n列表\r#\r\r无序列表\r#\r\r无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：\n* 无序列表一 + 无序列表二 - 无序列表二  无序列表一   无序列表二   无序列表三  有序列表\r#\r\r有序列表则使用数字接着一个英文句点：\n1. 有序列表一 2. 有序列表二  有序列表一 有序列表二  列表嵌套\r#\r\r列表嵌套只需在子列表中的选项添加四个空格即可\n1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素  第一项：  第一项嵌套的第一个元素 第一项嵌套的第二个元素   第二项：  第二项嵌套的第一个元素 第二项嵌套的第二个元素    区块\r#\r\r区块引用是在段落开头使用 \u0026gt; 符号 ，然后后面紧跟一个空格符号\nMarkdown 也允许你偷懒只在整个段落的第一行最前面加上 \u0026gt;\n引用的区块内也可使用其他的 Markdown 语法，包括标题、列表、代码区块等\n\u0026gt; 你是猪吗？孩子 \u0026gt;\u0026gt; 是的 我是猪 我真的是猪  你是猪吗？孩子\n 是的 我是猪\n我真的是猪\n  代码\r#\r\r行内代码：用反引号\u0026quot;`\u0026ldquo;包括起来\n`printf()` 函数 printf() 函数\n多行代码：\n(1)代码区块使用一个制表符(不推荐，格式有点不正常)\n(2)用六个反引号```包裹代码(后面可跟上c/java/php/js/py/go/xml/html/matlab/go等等)\npackage main import \u0026#34;fmt\u0026#34; func main(){ fmt.Println(\u0026#34;Hello,World!\u0026#34;); } 链接\r#\r\r超链接\r#\r\r[链接名称](链接地址 \u0026#34;链接标题，可不加\u0026#34;) or \u0026lt;链接地址\u0026gt; or [链接文字][链接标记] 在文本的任意位置添加 [链接标记]:链接地址 \u0026#34;链接标题\u0026#34; \r百度一下\n锚点\r#\r\r锚点其实就是页内超链接，实现快速跳到页面指定位置：\n目的地{#index} [跳转](#index) 目的地{#dst}\n跳转\n图片\r#\r\r![alt 属性文本](图片地址) or ![alt 属性文本](图片地址 \u0026#34;可选标题\u0026#34;) or ![alt 属性文本][标记] 在文本的任意位置添加 [标记]:图片地址 \u0026#34;可选标题\u0026#34; [alt 属性文本]其实是图片未正常显示时的替换文字。\n\r表格\r#\r\r第一行为表头，第二行分隔表头和主体部分\n使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。\n左对齐 | 右对齐 | 居中对齐 :-----| ----: | :----: 单元格 | 单元格 | 单元格 单元格 | 单元格 | 单元格    左对齐 右对齐 居中对齐     单元格 单元格 单元格   单元格 单元格 单元格    高级技巧\r#\r\rhtml原始码\r#\r\r在代码区块里面， \u0026amp; 、 \u0026lt; 和 \u0026gt; 会自动转成 HTML 实体\n\u0026lt;div class=\u0026#34;footer\u0026#34;\u0026gt; © 2004 Foo Corporation \u0026lt;/div\u0026gt; © 2004 Foo Corporation\r\r转义\r#\r\r\\ 反斜线 ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句点 ! 感叹号 公式\r#\r\r行内公式：\n$E=mc^2$ $E=mc^2$\n多行公式：\n$$E=mc^2$$ $$E=mc^2$$\nButtons\r#\r\r一种跳转到本地或外部链接的风格。\n{{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}} \rGet Home\r\rContribute\r\rColumns\r#\r\r{{\u0026lt; columns \u0026gt;}} **Left Content** Lorem markdownum insigne. \u0026lt;---\u0026gt; **Mid Content** Lorem markdownum insigne. \u0026lt;---\u0026gt; **Right Content** Lorem markdownum insigne. {{\u0026lt; /columns \u0026gt;}} Left Content\nLorem markdownum insigne.\n\rMid Content\nLorem markdownum insigne.\n\rRight Content\nLorem markdownum insigne.\n\r\rExpand\r#\r\r{{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} \r\rCustom Label\r...\r\r## Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat\nstringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\nprotulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes.\nMiseratus fonte Ditis conubia.\n\r\r\rHints\r#\r\r{{\u0026lt; hint [info|warning|danger] \u0026gt;}} 各种级别的提示信息。。。 {{\u0026lt; /hint \u0026gt;}} *info* 级别的提示信息···\r\r*warning* 级别的提示信息···\r\r*danger* 级别的提示信息···\r\rMermaid\r#\r\rMermaid是一种基于Javascript的绘图工具，使用类似于Markdown的语法，使用户可以方便快捷地通过代码创建图表。\n{{\u0026lt; mermaid \u0026gt;}} sequenceDiagram Alice-\u0026gt;\u0026gt;Bob: Hello Bob, how are you? alt is sick Bob-\u0026gt;\u0026gt;Alice: Not so good :( else is well Bob-\u0026gt;\u0026gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-\u0026gt;\u0026gt;Alice: Thanks for asking end {{\u0026lt; /mermaid \u0026gt;}} \r\rmermaid.initialize({\r\"flowchart\": {\r\"useMaxWidth\":true\r},\r\"theme\": \"default\"\r}\r)\rsequenceDiagram\rAlice-Bob: Hello Bob, how are you?\ralt is sick\rBob-Alice: Not so good :(\relse is well\rBob-Alice: Feeling fresh like a daisy\rend\ropt Extra response\rBob-Alice: Thanks for asking\rend\r ❤ 使用Typora可以更加方便的编写markdown文档，而不用手写代码，强力推荐。\n本文参考： Typora中文官网 Markdown中文官网 UML-Mermaid\n  菜鸟教程 \u0026ndash; 学的不仅是技术，更是梦想！！！ \u0026#x21a9;\u0026#xfe0e;\n  "},{"id":3,"href":"/posts/golang/%E5%9F%BA%E7%A1%80/Go%E8%AF%8D%E6%B3%95%E5%8D%95%E5%85%83/","title":"Go词法单元","section":"基础","content":"\r\rmermaid.initialize({\r\"flowchart\": {\r\"useMaxWidth\":true\r},\r\"theme\": \"default\"\r}\r)\rflowchart LR\rtoken -- 标识符 \u0026 操作符与分隔符 \u0026 字面常量\r标识符 -- 预声明标识符 \u0026 自定义标识符\r操作符与分隔符 -- 操作符 \u0026 纯分隔符\r字面常量 -- 整形字面量\\n浮点型字面量\\n复数型字面量\\n字符串字面量\\n字符型字面量\r预声明标识符 -- 关键字 \u0026 其它\r自定义标识符 -- user[包名 变量名 常量名\\n 函数名 自定义类型名\\n方法名]\r纯分隔符 -- cfgf[空白 制表符 回车 换行]\r其它 -- 类型标识符 \u0026 常量标识符 \u0026 空白标识符 \u0026 内置函数\r关键字(keywords)\r#\r\r   功能(25个) 关键字     引导整体程序结构 package import const var func defer go return   声明复合数据结构 struct interface map chan   控制程序结构 if else for range break continue switch select type case default fallthrough goto    类型标识符\r#\r\r   类型(20个) 值     整型 byte int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr   浮点型 float32 float64   复数型 complex64 complex128   字符和字符串型 string rune   接口型 interface   布尔型 bool    常量标识符\r#\r\r true false iota nil(指针/引用型变量默认值就是nil)\n 空白标识符\r#\r\r _ (声明匿名变量)\n 内置函数\r#\r\r共15个内置函数\n make new len cap append copy delete panic recover close complex real image print println\n 操作符\r#\r\r   类型(47个) 值     算术运算符 + - * / %   位运算符 \u0026amp; | ^ \u0026amp;^ \u0026raquo; \u0026laquo;   赋值和赋值复核运算符 := = += -= *= /= %= \u0026amp;= |= ^= \u0026amp;^= \u0026raquo;= \u0026laquo;=   比较运算符 \u0026gt; \u0026gt;= \u0026lt; \u0026lt;= == !=   括号 () {} []   逻辑运算符 \u0026amp;\u0026amp; || !   自增自减操作符 ++ \u0026ndash;   其他运算符 : , ; . \u0026hellip; \u0026lt;-    字面常量\r#\r\r表示固定值的符号叫做字面常量，简称字面量，其实就是具体的值而已。\n"},{"id":4,"href":"/posts/golang/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/","title":"数据类型和控制结构","section":"基础","content":"数据类型\r#\r\r常量和变量\r#\r\r变量：\nvar varName dataType [ = value ]\nvar varName = value\nvarName := value (只能在函数或方法内使用)\n常量： 布尔型、字符串型和数值型。\nconst name = value\n基本数据类型\r#\r\r   类型 值     整型 byte int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr   浮点型 float32 float64   复数型 complex64 complex128   字符 rune   字符串型 string   布尔型 bool    字符串类型\r#\r\r1、len() 函数求的是字符串字节的长度；\nlen(\u0026quot;H你\u0026quot;) = 4\r2、Go内置两种字符类型：一种是byte的字节类类型(uint8的别名)，另一种是表示Unicode编码的字符rune。 rune在Go内部是int32类型的别名，占用4个字节。Go语言默认的字符编码就是UTF-8类型的，如果需要特殊的编码转换，则使用Unicode/UTF-8标准包。\n复合数据类型\r#\r\r指针\r#\r\rGo中的指针及与指针对指针的操作主要有以下三种：\n一普通的指针类型，例如 var intptr *T，定义一个T类型指针变量\n二内置类型uintptr，本质是一个无符号的整型，它的长度是跟平台相关的，是一个能足够容纳指针位数大小的整数类型，可进行指针运算。\n三是unsafe包提供的Pointer，表示可以指向任意类型的指针。\n\r声明和初始化\nfunc main() { a := 10 b := \u0026amp;a fmt.Printf(\u0026#34;a:%d ptr:%p\\n\u0026#34;, a, \u0026amp;a) // a:10 ptr:0xc00001a078 \tfmt.Printf(\u0026#34;b:%p type:%T\\n\u0026#34;, b, b) // b:0xc00001a078 type:*int \tfmt.Println(\u0026amp;b) // 0xc00000e018 } 数组\r#\r\r声明和初始化\nvar arr [2]int var a = [3]int{1, 2, 3} a := [...]int{1, 2, 3} a := [3]int{1:1, 2:3} a := [...]int{1:1, 2:3} 说明\n数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。\n切片\r#\r\r声明和初始化\n1、定义切片类型 var a []int //nil var b = []int{} var c = []int{1, 2} 2、由数组创建 a := [5]int{1, 2, 3, 4, 5} s := a[1:3] // s := a[low:high]，左闭右开  3、make创建 var a = make([]int, 2, 10) 说明\n切片是一个引用类型，它是基于数组类型做的一层封装，它的内部结构包含地址、长度和容量。\nmap\r#\r\r声明和初始化\n1、定义map类型 var a map[int]string //nil var b = map[int]string{1:\u0026#34;1\u0026#34;, 2:\u0026#34;2\u0026#34;} 2、make创建 var m = make(map[string]int, 2, 10) 说明\nmap是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。\n特别用法\n//判断某个键是否存在 value, ok := map[key] struct\r#\r\r声明和初始化\n1、匿名结构体 struct { FieldName FieldType } //在定义的时候初始化，可以赋值给变量  2、自定义struct类型 type TypeName struct { FieldName FieldType } chan\r#\r\r声明和初始化\n1、定义chan类型 var a chan int var b chan\u0026lt;- int //单向写通道 var c \u0026lt;-chan int //单向读通道  2、make创建 var c = make(chan int) var c = make(chan int, 10) //10个缓冲的通道 说明\n1、无缓冲的通道既可以用于通信，也可用于两个goroutine的同步；有缓冲的通道主要用于通信；\n2、若close(chan)后，则写数据会panic，而读数据会返回通道元素的零值；可通过comma, ok表达式判断chan是否关闭；\n3、向缓冲区已满的通道写数据会协程阻塞，读取没数据(未关闭)的通道也会协程阻塞；\n4、向未初始化的通道读写数据都会造成协程的永久阻塞；\n5、重复关闭通道会导致panic。\nmake和new的区别：\n1、make和new都是用来申请内存的；\n2、new很少用，一般用来给基本数据类型申请内存，string、int等返回的是对应类型的指针(*string, *int)；\n3、make是用来给slice、map、chan申请内存的，name函数返回的是对应这三个类型本身。\r\r控制结构\r#\r\rif语句\r#\r\rif x:= f(); x \u0026lt; y {\t//初始化语句中声明变量x  return x } else if x \u0026gt; z { return z } else { return y } switch语句\r#\r\rswitch i := f(); i { case a: fmt.Println(\u0026#34;1\u0026#34;) case b: fmt.Println(\u0026#34;2\u0026#34;) fallthrough\t//强制执行下一个case语句，不再判断下一个case语句是否满足条件 case c: fmt.Println(\u0026#34;3\u0026#34;) default: fmt.Println(\u0026#34;bye\u0026#34;) } for语句\r#\r\r1、类似于C循环中的for语句 for init; condition; post {} 2、类似C的while语句 for condition {} 3、类似于C的while(1)死循环 for {} 4、对数组、切片、字符串、map和通道的访问 for k, v := range Type {} 标签和跳转\r#\r\r1、使用标签(Label)来标识一个语句的位置； Label: Statement 2、goto、break、continue可以单独使用，也可以和标签配合使用跳到指定位置； 3、return用于函数和方法的退出。 例如: if n%2 == 1 { goto L1 } for n \u0026gt; 0 { f() n-- L1: f() n-- } "},{"id":5,"href":"/posts/golang/%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0/","title":"函数","section":"基础","content":"基本使用\r#\r\r\r函数签名\r#\r\r匿名函数\r#\r\rdefer\r#\r\r闭包\r#\r\rpanic和recover\r#\r\r错误处理\r#\r\r"},{"id":6,"href":"/posts/list/","title":"总览","section":"Posts","content":"本博客计划技能图谱如下，脑图中分类对应博客的分类，不断补充中\u0026hellip;\u0026hellip;..\n\r"},{"id":7,"href":"/posts/About/","title":"About","section":"Posts","content":"一个爱好编程的大男孩。\n 爱好骑行，爬山，音乐和漫无目的走在大街上。\n 意见和交流请邮件 meng_zhao@foxmail.com.\n"}]